#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 1000 8000
    bytecblock "reserveA" "reserveB" "totalLp" "lp_" 0x151f7c75 0x00 "FEE_NUM" "FEE_DEN" "assetA" "assetB" 0x068101
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    intc_0 // 0
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    intc_0 // 0
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_2 // "totalLp"
    intc_0 // 0
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:29
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    bytec 6 // "FEE_NUM"
    pushint 997 // 997
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    bytec 7 // "FEE_DEN"
    intc_2 // 1000
    app_global_put

main_after_if_else@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@18
    pushbytess 0x21d6d0b6 0xd70adabb 0xe4971963 0xfee44ae0 0x43e9d739 0x8241bf3f 0x48afc4e8 0x054fa8b4 0xcc2ae2d6 0xcf85697e 0xcf044285 // method "createPool(asset,asset)bool", method "addLiquidity(uint64,uint64)bool", method "removeLiquidity(uint64)bool", method "swap(uint64,uint64)bool", method "optIn()bool", method "getLpBalance(account)uint64", method "getAssetAId()uint64", method "getAssetBId()uint64", method "getReserveA()uint64", method "getReserveB()uint64", method "getTotalLp()uint64"
    txna ApplicationArgs 0
    match main_createPool_route@5 main_addLiquidity_route@6 main_removeLiquidity_route@7 main_swap_route@8 main_optIn_route@9 main_getLpBalance_route@10 main_getAssetAId_route@11 main_getAssetBId_route@12 main_getReserveA_route@13 main_getReserveB_route@14 main_getTotalLp_route@15

main_after_if_else@22:
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    intc_0 // 0
    return

main_getTotalLp_route@15:
    // smart_contracts/swap_contract/AMMContract.algo.ts:208
    // public getTotalLp(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getTotalLp
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getReserveB_route@14:
    // smart_contracts/swap_contract/AMMContract.algo.ts:203
    // public getReserveB(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getReserveB
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getReserveA_route@13:
    // smart_contracts/swap_contract/AMMContract.algo.ts:198
    // public getReserveA(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getReserveA
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getAssetBId_route@12:
    // smart_contracts/swap_contract/AMMContract.algo.ts:193
    // public getAssetBId(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getAssetBId
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getAssetAId_route@11:
    // smart_contracts/swap_contract/AMMContract.algo.ts:188
    // public getAssetAId(): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getAssetAId
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getLpBalance_route@10:
    // smart_contracts/swap_contract/AMMContract.algo.ts:180
    // public getLpBalance(account: Account): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Accounts
    // smart_contracts/swap_contract/AMMContract.algo.ts:180
    // public getLpBalance(account: Account): uint64 {
    callsub getLpBalance
    itob
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_optIn_route@9:
    // smart_contracts/swap_contract/AMMContract.algo.ts:170
    // public optIn(): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub optIn
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_swap_route@8:
    // smart_contracts/swap_contract/AMMContract.algo.ts:126-129
    // public swap(
    //   sendAssetType: uint64, // 1 if asset_a -> b, 2 if asset_b -> a
    //   swapAmount: uint64
    // ): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:126-129
    // public swap(
    //   sendAssetType: uint64, // 1 if asset_a -> b, 2 if asset_b -> a
    //   swapAmount: uint64
    // ): boolean {
    callsub swap
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeLiquidity_route@7:
    // smart_contracts/swap_contract/AMMContract.algo.ts:100
    // public removeLiquidity(lpToBurn: uint64): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:100
    // public removeLiquidity(lpToBurn: uint64): boolean {
    callsub removeLiquidity
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_addLiquidity_route@6:
    // smart_contracts/swap_contract/AMMContract.algo.ts:55-58
    // public addLiquidity(
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:55-58
    // public addLiquidity(
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    callsub addLiquidity
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createPool_route@5:
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    callsub createPool
    bytec 5 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec 4 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@18:
    // smart_contracts/swap_contract/AMMContract.algo.ts:17
    // export class AMMContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@22
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 10 // 0x068101
    itxn_field ApprovalProgram
    bytec 10 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.createPool(assetIdA: uint64, assetIdB: uint64) -> uint64:
createPool:
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:34
    // ensureBudget(3000)
    pushint 3000 // 3000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // private assetA = GlobalState<Asset>()
    bytec 8 // "assetA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:35
    // this.assetA.value = assetIdA;
    frame_dig -2
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:20
    // private assetB = GlobalState<Asset>()
    bytec 9 // "assetB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:36
    // this.assetB.value = assetIdB;
    frame_dig -1
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:38
    // this.optInToAsset(assetIdA);
    frame_dig -2
    callsub optInToAsset
    // smart_contracts/swap_contract/AMMContract.algo.ts:39
    // this.optInToAsset(assetIdB);
    frame_dig -1
    callsub optInToAsset
    // smart_contracts/swap_contract/AMMContract.algo.ts:40
    // return true
    intc_1 // 1
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.optInToAsset(assetId: uint64) -> void:
optInToAsset:
    // smart_contracts/swap_contract/AMMContract.algo.ts:44
    // private optInToAsset(assetId: Asset): void {
    proto 1 0
    // smart_contracts/swap_contract/AMMContract.algo.ts:45-51
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // 
    // }).submit();
    itxn_begin
    // smart_contracts/swap_contract/AMMContract.algo.ts:47
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/swap_contract/AMMContract.algo.ts:46
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    // smart_contracts/swap_contract/AMMContract.algo.ts:45-51
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // 
    // }).submit();
    pushint 4 // 4
    itxn_field TypeEnum
    // smart_contracts/swap_contract/AMMContract.algo.ts:48
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/swap_contract/AMMContract.algo.ts:45-51
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // 
    // }).submit();
    itxn_submit
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.addLiquidity(assetAAmount: uint64, assetBAmount: uint64) -> uint64:
addLiquidity:
    // smart_contracts/swap_contract/AMMContract.algo.ts:55-58
    // public addLiquidity(
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:59
    // ensureBudget(8000)
    intc_3 // 8000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:61
    // assert(Global.groupSize === 3, "Expected group size of 3 (app call + 2 asset transfers)");
    global GroupSize
    pushint 3 // 3
    ==
    assert // Expected group size of 3 (app call + 2 asset transfers)
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // private assetA = GlobalState<Asset>()
    intc_0 // 0
    bytec 8 // "assetA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:65
    // assert(this.assetA.hasValue && this.assetB.hasValue, "Pool not initialized")
    app_global_get_ex
    bury 1
    bz addLiquidity_bool_false@3
    // smart_contracts/swap_contract/AMMContract.algo.ts:20
    // private assetB = GlobalState<Asset>()
    intc_0 // 0
    bytec 9 // "assetB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:65
    // assert(this.assetA.hasValue && this.assetB.hasValue, "Pool not initialized")
    app_global_get_ex
    bury 1
    bz addLiquidity_bool_false@3
    intc_1 // 1

addLiquidity_bool_merge@4:
    // smart_contracts/swap_contract/AMMContract.algo.ts:65
    // assert(this.assetA.hasValue && this.assetB.hasValue, "Pool not initialized")
    assert // Pool not initialized
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:67
    // if (this.totalLp.value === Uint64(0)) {
    bnz addLiquidity_else_body@6
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:69
    // this.reserveA.value = assetAAmount
    frame_dig -2
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:70
    // this.reserveB.value = assetBAmount
    frame_dig -1
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_2 // "totalLp"
    // smart_contracts/swap_contract/AMMContract.algo.ts:71
    // this.totalLp.value = Uint64(1000)
    intc_2 // 1000
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:74
    // this.lpBalances(Txn.sender).value = Uint64(1000)
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:74
    // this.lpBalances(Txn.sender).value = Uint64(1000)
    intc_2 // 1000
    itob
    box_put

addLiquidity_after_if_else@10:
    // smart_contracts/swap_contract/AMMContract.algo.ts:96
    // return true
    intc_1 // 1
    retsub

addLiquidity_else_body@6:
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:77
    // const lpMintedA: uint64 = assetAAmount * this.totalLp.value / this.reserveA.value
    frame_dig -2
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:77
    // const lpMintedA: uint64 = assetAAmount * this.totalLp.value / this.reserveA.value
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:78
    // const lpMintedB: uint64 = assetBAmount * this.totalLp.value / this.reserveB.value
    frame_dig -1
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:78
    // const lpMintedB: uint64 = assetBAmount * this.totalLp.value / this.reserveB.value
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:81
    // const lpToMint = lpMintedA < lpMintedB ? lpMintedA : lpMintedB
    dup2
    <
    swap
    cover 2
    select
    dup
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:84
    // this.reserveA.value += assetAAmount
    frame_dig -2
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:84
    // this.reserveA.value += assetAAmount
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:85
    // this.reserveB.value += assetBAmount
    frame_dig -1
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:85
    // this.reserveB.value += assetBAmount
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:86
    // this.totalLp.value += lpToMint
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_2 // "totalLp"
    // smart_contracts/swap_contract/AMMContract.algo.ts:86
    // this.totalLp.value += lpToMint
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:89
    // if (!this.lpBalances(Txn.sender).exists) {
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:89
    // if (!this.lpBalances(Txn.sender).exists) {
    box_len
    bury 1
    bnz addLiquidity_else_body@8
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:90
    // this.lpBalances(Txn.sender).value = lpToMint
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:90
    // this.lpBalances(Txn.sender).value = lpToMint
    swap
    itob
    box_put
    b addLiquidity_after_if_else@10

addLiquidity_else_body@8:
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:92
    // this.lpBalances(Txn.sender).value += lpToMint
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:92
    // this.lpBalances(Txn.sender).value += lpToMint
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:92
    // this.lpBalances(Txn.sender).value += lpToMint
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:92
    // this.lpBalances(Txn.sender).value += lpToMint
    swap
    uncover 2
    +
    itob
    box_put
    b addLiquidity_after_if_else@10

addLiquidity_bool_false@3:
    intc_0 // 0
    b addLiquidity_bool_merge@4


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.removeLiquidity(lpToBurn: uint64) -> uint64:
removeLiquidity:
    // smart_contracts/swap_contract/AMMContract.algo.ts:100
    // public removeLiquidity(lpToBurn: uint64): boolean {
    proto 1 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:101
    // ensureBudget(8000)
    intc_3 // 8000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:102
    // assert(this.lpBalances(Txn.sender).exists, "No LP balance found")
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:102
    // assert(this.lpBalances(Txn.sender).exists, "No LP balance found")
    box_len
    bury 1
    assert // No LP balance found
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:103
    // const userLp = this.lpBalances(Txn.sender).value
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:103
    // const userLp = this.lpBalances(Txn.sender).value
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:106
    // assert(lpToBurn > Uint64(0), "Must burn positive amount")
    frame_dig -1
    assert // Must burn positive amount
    // smart_contracts/swap_contract/AMMContract.algo.ts:107
    // assert(userLp >= lpToBurn, "Insufficient LP balance")
    frame_dig -1
    >=
    assert // Insufficient LP balance
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:110
    // const amtA: uint64 = this.reserveA.value * lpToBurn / this.totalLp.value
    frame_dig -1
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:110
    // const amtA: uint64 = this.reserveA.value * lpToBurn / this.totalLp.value
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:111
    // const amtB: uint64 = this.reserveB.value * lpToBurn / this.totalLp.value
    frame_dig -1
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:111
    // const amtB: uint64 = this.reserveB.value * lpToBurn / this.totalLp.value
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:114
    // this.reserveA.value -= amtA
    uncover 2
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:114
    // this.reserveA.value -= amtA
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:115
    // this.reserveB.value -= amtB
    swap
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:115
    // this.reserveB.value -= amtB
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:116
    // this.totalLp.value -= lpToBurn
    frame_dig -1
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_2 // "totalLp"
    // smart_contracts/swap_contract/AMMContract.algo.ts:116
    // this.totalLp.value -= lpToBurn
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:117
    // this.lpBalances(Txn.sender).value -= lpToBurn
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:117
    // this.lpBalances(Txn.sender).value -= lpToBurn
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:117
    // this.lpBalances(Txn.sender).value -= lpToBurn
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:117
    // this.lpBalances(Txn.sender).value -= lpToBurn
    swap
    frame_dig -1
    -
    itob
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:122
    // return true
    intc_1 // 1
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.swap(sendAssetType: uint64, swapAmount: uint64) -> uint64:
swap:
    // smart_contracts/swap_contract/AMMContract.algo.ts:126-129
    // public swap(
    //   sendAssetType: uint64, // 1 if asset_a -> b, 2 if asset_b -> a
    //   swapAmount: uint64
    // ): boolean {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:130
    // ensureBudget(7000)
    pushint 7000 // 7000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:132
    // assert(Global.groupSize === 2, "Expected group size of 2 (app call + asset transfer)");
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected group size of 2 (app call + asset transfer)
    // smart_contracts/swap_contract/AMMContract.algo.ts:134
    // if (sendAssetType === Uint64(1)) {
    frame_dig -2
    intc_1 // 1
    ==
    bz swap_else_body@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:136
    // const resA: uint64 = this.reserveA.value + swapAmount
    frame_dig -1
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:140
    // const k: uint64 = this.reserveA.value * this.reserveB.value
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    intc_0 // 0
    bytec 7 // "FEE_DEN"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:141
    // const newB: uint64 = k * Uint64(this.FEE_DEN.value) / (resA * Uint64(this.FEE_NUM.value))
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:29
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    intc_0 // 0
    bytec 6 // "FEE_NUM"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:141
    // const newB: uint64 = k * Uint64(this.FEE_DEN.value) / (resA * Uint64(this.FEE_NUM.value))
    dig 3
    *
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:142
    // const outB: uint64 = resB - newB
    dig 1
    swap
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:145
    // this.reserveA.value = resA
    uncover 3
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:146
    // this.reserveB.value = resB - outB
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:146
    // this.reserveB.value = resB - outB
    swap
    app_global_put

swap_after_if_else@3:
    // smart_contracts/swap_contract/AMMContract.algo.ts:166
    // return true
    intc_1 // 1
    retsub

swap_else_body@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:151
    // const resB: uint64 = this.reserveB.value + swapAmount
    frame_dig -1
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:155
    // const k: uint64 = this.reserveA.value * this.reserveB.value
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    intc_0 // 0
    bytec 7 // "FEE_DEN"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:156
    // const newA: uint64 = k * Uint64(this.FEE_DEN.value) / (resB * Uint64(this.FEE_NUM.value))
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:29
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    intc_0 // 0
    bytec 6 // "FEE_NUM"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:156
    // const newA: uint64 = k * Uint64(this.FEE_DEN.value) / (resB * Uint64(this.FEE_NUM.value))
    dig 3
    *
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:157
    // const outA: uint64 = resA - newA
    dig 1
    swap
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:160
    // this.reserveA.value = resA - outA
    -
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_0 // "reserveA"
    // smart_contracts/swap_contract/AMMContract.algo.ts:160
    // this.reserveA.value = resA - outA
    swap
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    bytec_1 // "reserveB"
    // smart_contracts/swap_contract/AMMContract.algo.ts:161
    // this.reserveB.value = resB
    swap
    app_global_put
    b swap_after_if_else@3


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.optIn() -> uint64:
optIn:
    // smart_contracts/swap_contract/AMMContract.algo.ts:171
    // ensureBudget(1000)
    intc_2 // 1000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:173
    // if (!this.lpBalances(Txn.sender).exists) {
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:173
    // if (!this.lpBalances(Txn.sender).exists) {
    box_len
    bury 1
    bnz optIn_after_if_else@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    // smart_contracts/swap_contract/AMMContract.algo.ts:174
    // this.lpBalances(Txn.sender).value = Uint64(0)
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:174
    // this.lpBalances(Txn.sender).value = Uint64(0)
    intc_0 // 0
    itob
    box_put

optIn_after_if_else@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:176
    // return true
    intc_1 // 1
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getLpBalance(account: bytes) -> uint64:
getLpBalance:
    // smart_contracts/swap_contract/AMMContract.algo.ts:180
    // public getLpBalance(account: Account): uint64 {
    proto 1 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public lpBalances = BoxMap<Account, uint64>({ keyPrefix: Bytes`lp_` })
    bytec_3 // "lp_"
    frame_dig -1
    concat
    dup
    // smart_contracts/swap_contract/AMMContract.algo.ts:181
    // if (!this.lpBalances(account).exists) {
    box_len
    bury 1
    bnz getLpBalance_after_if_else@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:182
    // return Uint64(0)
    intc_0 // 0
    swap
    retsub

getLpBalance_after_if_else@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:184
    // return this.lpBalances(account).value
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    swap
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getAssetAId() -> uint64:
getAssetAId:
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // private assetA = GlobalState<Asset>()
    intc_0 // 0
    bytec 8 // "assetA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:189
    // return this.assetA.value.id
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getAssetBId() -> uint64:
getAssetBId:
    // smart_contracts/swap_contract/AMMContract.algo.ts:20
    // private assetB = GlobalState<Asset>()
    intc_0 // 0
    bytec 9 // "assetB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:194
    // return this.assetB.value.id
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getReserveA() -> uint64:
getReserveA:
    // smart_contracts/swap_contract/AMMContract.algo.ts:21
    // private reserveA = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_0 // "reserveA"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:199
    // return this.reserveA.value
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getReserveB() -> uint64:
getReserveB:
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // private reserveB = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_1 // "reserveB"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:204
    // return this.reserveB.value
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::AMMContract.getTotalLp() -> uint64:
getTotalLp:
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // private totalLp = GlobalState<uint64>({ initialValue: Uint64(0) })
    intc_0 // 0
    bytec_2 // "totalLp"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:209
    // return this.totalLp.value
    retsub
