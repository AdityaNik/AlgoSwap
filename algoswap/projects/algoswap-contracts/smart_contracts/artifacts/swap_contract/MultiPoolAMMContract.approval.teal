#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 4 1000
    bytecblock 0x151f7c75 "pa_" 0x00 "pb_" "ra_" "rb_" "lp_" "bal_" "FEE_NUM" "FEE_DEN" 0x068101
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    bytec 8 // "FEE_NUM"
    pushint 997 // 997
    app_global_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:34
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    bytec 9 // "FEE_DEN"
    intc_3 // 1000
    app_global_put

main_after_if_else@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txn NumAppArgs
    bz main_bare_routing@14
    pushbytess 0x21d6d0b6 0x5b76a759 0x3d948581 0x75d300f9 0x2faf0305 0x3d9d442c 0xeeabb581 // method "createPool(asset,asset)bool", method "addLiquidity(asset,asset,uint64,uint64)bool", method "removeLiquidity(asset,asset,uint64)bool", method "swap(asset,asset,asset,uint64)bool", method "getLpBalance(asset,asset,account)uint64", method "getPoolInfo(asset,asset)(uint64,uint64,uint64,uint64,uint64)", method "poolExists(asset,asset)bool"
    txna ApplicationArgs 0
    match main_createPool_route@5 main_addLiquidity_route@6 main_removeLiquidity_route@7 main_swap_route@8 main_getLpBalance_route@9 main_getPoolInfo_route@10 main_poolExists_route@11

main_after_if_else@18:
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    intc_0 // 0
    return

main_poolExists_route@11:
    // smart_contracts/swap_contract/AMMContract.algo.ts:321
    // public poolExists(assetIdA: Asset, assetIdB: Asset): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/swap_contract/AMMContract.algo.ts:321
    // public poolExists(assetIdA: Asset, assetIdB: Asset): boolean {
    callsub poolExists
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getPoolInfo_route@10:
    // smart_contracts/swap_contract/AMMContract.algo.ts:301
    // public getPoolInfo(assetIdA: Asset, assetIdB: Asset): [uint64, uint64, uint64, uint64, uint64] {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/swap_contract/AMMContract.algo.ts:301
    // public getPoolInfo(assetIdA: Asset, assetIdB: Asset): [uint64, uint64, uint64, uint64, uint64] {
    callsub getPoolInfo
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    itob
    uncover 4
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_getLpBalance_route@9:
    // smart_contracts/swap_contract/AMMContract.algo.ts:290
    // public getLpBalance(assetIdA: Asset, assetIdB: Asset, account: Account): uint64 {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txnas Accounts
    // smart_contracts/swap_contract/AMMContract.algo.ts:290
    // public getLpBalance(assetIdA: Asset, assetIdB: Asset, account: Account): uint64 {
    callsub getLpBalance
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_swap_route@8:
    // smart_contracts/swap_contract/AMMContract.algo.ts:225-230
    // public swap(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   sendAssetId: Asset,
    //   swapAmount: uint64
    // ): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txnas Assets
    txna ApplicationArgs 4
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:225-230
    // public swap(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   sendAssetId: Asset,
    //   swapAmount: uint64
    // ): boolean {
    callsub swap
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_removeLiquidity_route@7:
    // smart_contracts/swap_contract/AMMContract.algo.ts:165-169
    // public removeLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   lpToBurn: uint64
    // ): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:165-169
    // public removeLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   lpToBurn: uint64
    // ): boolean {
    callsub removeLiquidity
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_addLiquidity_route@6:
    // smart_contracts/swap_contract/AMMContract.algo.ts:106-111
    // public addLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/swap_contract/AMMContract.algo.ts:106-111
    // public addLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    callsub addLiquidity
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createPool_route@5:
    // smart_contracts/swap_contract/AMMContract.algo.ts:63
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txna ApplicationArgs 1
    btoi
    txnas Assets
    txna ApplicationArgs 2
    btoi
    txnas Assets
    // smart_contracts/swap_contract/AMMContract.algo.ts:63
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    callsub createPool
    bytec_2 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@14:
    // smart_contracts/swap_contract/AMMContract.algo.ts:19
    // export class MultiPoolAMMContract extends Contract {
    txn OnCompletion
    bnz main_after_if_else@18
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10 // 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@7
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 10 // 0x068101
    itxn_field ApprovalProgram
    bytec 10 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@6:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@6

ensure_budget_after_while@7:
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.getPoolKey(assetIdA: uint64, assetIdB: uint64) -> bytes:
getPoolKey:
    // smart_contracts/swap_contract/AMMContract.algo.ts:37
    // private getPoolKey(assetIdA: Asset, assetIdB: Asset): bytes {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:42
    // if (idA < idB) {
    frame_dig -2
    frame_dig -1
    <
    bz getPoolKey_else_body@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:44
    // const bytesA = itob(idA);
    frame_dig -2
    itob
    // smart_contracts/swap_contract/AMMContract.algo.ts:45
    // const bytesB = itob(idB);
    frame_dig -1
    itob
    // smart_contracts/swap_contract/AMMContract.algo.ts:46
    // return bytesA.concat(bytesB);
    concat
    retsub

getPoolKey_else_body@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:48
    // const bytesA = itob(idA);
    frame_dig -2
    itob
    // smart_contracts/swap_contract/AMMContract.algo.ts:49
    // const bytesB = itob(idB);
    frame_dig -1
    itob
    // smart_contracts/swap_contract/AMMContract.algo.ts:50
    // return bytesB.concat(bytesA);
    swap
    concat
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.createPool(assetIdA: uint64, assetIdB: uint64) -> uint64:
createPool:
    // smart_contracts/swap_contract/AMMContract.algo.ts:63
    // public createPool(assetIdA: Asset, assetIdB: Asset): boolean {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:64
    // ensureBudget(5000);
    pushint 5000 // 5000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:65
    // assert(assetIdA !== assetIdB, "Cannot create pool with same asset");
    frame_dig -2
    frame_dig -1
    !=
    assert // Cannot create pool with same asset
    // smart_contracts/swap_contract/AMMContract.algo.ts:70
    // const poolKey = this.getPoolKey(assetA, assetB);
    frame_dig -2
    frame_dig -1
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:71
    // assert(!this.poolAssetA(poolKey).exists, "Pool already exists");
    dup
    box_len
    bury 1
    !
    assert // Pool already exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:74
    // const orderedAssetA = assetA.id < assetB.id ? assetA : assetB;
    frame_dig -2
    frame_dig -1
    <
    frame_dig -1
    frame_dig -2
    dig 2
    select
    // smart_contracts/swap_contract/AMMContract.algo.ts:75
    // const orderedAssetB = assetA.id < assetB.id ? assetB : assetA;
    frame_dig -2
    frame_dig -1
    uncover 3
    select
    // smart_contracts/swap_contract/AMMContract.algo.ts:78
    // this.poolAssetA(poolKey).value = orderedAssetA;
    dig 1
    itob
    uncover 3
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // public poolAssetB = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pb_` });
    bytec_3 // "pb_"
    dig 3
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:79
    // this.poolAssetB(poolKey).value = orderedAssetB;
    dig 1
    itob
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:24
    // public poolReserveA = BoxMap<bytes, uint64>({ keyPrefix: Bytes`ra_` });
    bytec 4 // "ra_"
    dig 3
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:80
    // this.poolReserveA(poolKey).value = Uint64(0);
    intc_0 // 0
    itob
    swap
    dig 1
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:25
    // public poolReserveB = BoxMap<bytes, uint64>({ keyPrefix: Bytes`rb_` });
    bytec 5 // "rb_"
    dig 4
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:81
    // this.poolReserveB(poolKey).value = Uint64(0);
    dig 1
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public poolTotalLp = BoxMap<bytes, uint64>({ keyPrefix: Bytes`lp_` });
    bytec 6 // "lp_"
    dig 4
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:82
    // this.poolTotalLp(poolKey).value = Uint64(0);
    dig 1
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:85
    // const lpKey = this.getLpBalanceKey(poolKey, Txn.sender);
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:59
    // return poolKey.concat(accountBytes);
    uncover 4
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // public lpBalances = BoxMap<bytes, uint64>({ keyPrefix: Bytes`bal_` });
    bytec 7 // "bal_"
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:86
    // this.lpBalances(lpKey).value = Uint64(0);
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:89
    // this.optInToAsset(orderedAssetA);
    swap
    callsub optInToAsset
    // smart_contracts/swap_contract/AMMContract.algo.ts:90
    // this.optInToAsset(orderedAssetB);
    callsub optInToAsset
    // smart_contracts/swap_contract/AMMContract.algo.ts:92
    // return true;
    intc_1 // 1
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.optInToAsset(assetId: uint64) -> void:
optInToAsset:
    // smart_contracts/swap_contract/AMMContract.algo.ts:96
    // private optInToAsset(assetId: Asset): void {
    proto 1 0
    // smart_contracts/swap_contract/AMMContract.algo.ts:97-102
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // }).submit();
    itxn_begin
    // smart_contracts/swap_contract/AMMContract.algo.ts:99
    // assetReceiver: Global.currentApplicationAddress,
    global CurrentApplicationAddress
    frame_dig -1
    itxn_field XferAsset
    itxn_field AssetReceiver
    // smart_contracts/swap_contract/AMMContract.algo.ts:98
    // assetAmount: 0,
    intc_0 // 0
    itxn_field AssetAmount
    // smart_contracts/swap_contract/AMMContract.algo.ts:97-102
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/swap_contract/AMMContract.algo.ts:100
    // fee: 0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/swap_contract/AMMContract.algo.ts:97-102
    // itxn.assetTransfer({
    //   assetAmount: 0,
    //   assetReceiver: Global.currentApplicationAddress,
    //   fee: 0,
    //   xferAsset: assetId,
    // }).submit();
    itxn_submit
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.addLiquidity(assetIdA: uint64, assetIdB: uint64, assetAAmount: uint64, assetBAmount: uint64) -> uint64:
addLiquidity:
    // smart_contracts/swap_contract/AMMContract.algo.ts:106-111
    // public addLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   assetAAmount: uint64,
    //   assetBAmount: uint64
    // ): boolean {
    proto 4 1
    pushbytes ""
    // smart_contracts/swap_contract/AMMContract.algo.ts:112
    // ensureBudget(10000);
    pushint 10000 // 10000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:114
    // assert(Global.groupSize === 3, "Expected group size of 3 (app call + 2 asset transfers)");
    global GroupSize
    pushint 3 // 3
    ==
    assert // Expected group size of 3 (app call + 2 asset transfers)
    // smart_contracts/swap_contract/AMMContract.algo.ts:119
    // const poolKey = this.getPoolKey(assetA, assetB);
    frame_dig -4
    frame_dig -3
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:120
    // assert(this.poolAssetA(poolKey).exists, "Pool does not exist");
    dup
    box_len
    bury 1
    assert // Pool does not exist
    // smart_contracts/swap_contract/AMMContract.algo.ts:122
    // const poolAssetA = this.poolAssetA(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // public poolAssetB = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pb_` });
    bytec_3 // "pb_"
    dig 2
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:123
    // const poolAssetB = this.poolAssetB(poolKey).value;
    box_get
    bury 1
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:24
    // public poolReserveA = BoxMap<bytes, uint64>({ keyPrefix: Bytes`ra_` });
    bytec 4 // "ra_"
    dig 2
    concat
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:124
    // const reserveA = this.poolReserveA(poolKey).value;
    box_get
    swap
    btoi
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:25
    // public poolReserveB = BoxMap<bytes, uint64>({ keyPrefix: Bytes`rb_` });
    bytec 5 // "rb_"
    dig 2
    concat
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:125
    // const reserveB = this.poolReserveB(poolKey).value;
    box_get
    swap
    btoi
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public poolTotalLp = BoxMap<bytes, uint64>({ keyPrefix: Bytes`lp_` });
    bytec 6 // "lp_"
    dig 2
    concat
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:126
    // const totalLp = this.poolTotalLp(poolKey).value;
    box_get
    swap
    btoi
    dup
    cover 3
    cover 5
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:128
    // const lpKey = this.getLpBalanceKey(poolKey, Txn.sender);
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:59
    // return poolKey.concat(accountBytes);
    uncover 3
    swap
    concat
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:131
    // const amountA = assetA.id === poolAssetA.id ? assetAAmount : assetBAmount;
    frame_dig -4
    ==
    frame_dig -1
    frame_dig -2
    dig 2
    select
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:132
    // const amountB = assetA.id === poolAssetA.id ? assetBAmount : assetAAmount;
    frame_dig -2
    frame_dig -1
    uncover 2
    select
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:134
    // if (totalLp === Uint64(0)) {
    bnz addLiquidity_else_body@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:136
    // this.poolReserveA(poolKey).value = amountA;
    swap
    itob
    frame_dig 1
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:137
    // this.poolReserveB(poolKey).value = amountB;
    frame_dig 7
    itob
    frame_dig 3
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:138
    // this.poolTotalLp(poolKey).value = Uint64(1000);
    intc_3 // 1000
    itob
    swap
    dig 1
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // public lpBalances = BoxMap<bytes, uint64>({ keyPrefix: Bytes`bal_` });
    bytec 7 // "bal_"
    frame_dig 6
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:140
    // this.lpBalances(lpKey).value = Uint64(1000);
    swap
    box_put

addLiquidity_after_if_else@6:
    // smart_contracts/swap_contract/AMMContract.algo.ts:161
    // return true;
    intc_1 // 1
    frame_bury 0
    retsub

addLiquidity_else_body@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:143
    // const lpMintedA: uint64 = amountA * totalLp / reserveA;
    swap
    dup
    frame_dig 5
    dup
    cover 2
    *
    frame_dig 2
    dup
    cover 3
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:144
    // const lpMintedB: uint64 = amountB * totalLp / reserveB;
    frame_dig 7
    dup
    cover 5
    dig 2
    *
    frame_dig 4
    dup
    cover 4
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:146
    // const lpToMint = lpMintedA < lpMintedB ? lpMintedA : lpMintedB;
    dup2
    <
    swap
    cover 2
    select
    dup
    cover 3
    frame_bury 0
    // smart_contracts/swap_contract/AMMContract.algo.ts:149
    // this.poolReserveA(poolKey).value = reserveA + amountA;
    uncover 3
    uncover 4
    +
    itob
    frame_dig 1
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:150
    // this.poolReserveB(poolKey).value = reserveB + amountB;
    swap
    uncover 3
    +
    itob
    frame_dig 3
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:151
    // this.poolTotalLp(poolKey).value = totalLp + lpToMint;
    +
    itob
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // public lpBalances = BoxMap<bytes, uint64>({ keyPrefix: Bytes`bal_` });
    bytec 7 // "bal_"
    frame_dig 6
    concat
    dup
    // smart_contracts/swap_contract/AMMContract.algo.ts:154
    // if (!this.lpBalances(lpKey).exists) {
    box_len
    bury 1
    bnz addLiquidity_else_body@4
    // smart_contracts/swap_contract/AMMContract.algo.ts:155
    // this.lpBalances(lpKey).value = lpToMint;
    frame_dig 0
    itob
    box_put
    b addLiquidity_after_if_else@6

addLiquidity_else_body@4:
    // smart_contracts/swap_contract/AMMContract.algo.ts:157
    // this.lpBalances(lpKey).value += lpToMint;
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_dig 0
    +
    itob
    box_put
    b addLiquidity_after_if_else@6


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.removeLiquidity(assetIdA: uint64, assetIdB: uint64, lpToBurn: uint64) -> uint64:
removeLiquidity:
    // smart_contracts/swap_contract/AMMContract.algo.ts:165-169
    // public removeLiquidity(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   lpToBurn: uint64
    // ): boolean {
    proto 3 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:170
    // ensureBudget(10000);
    pushint 10000 // 10000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:175
    // const poolKey = this.getPoolKey(assetA, assetB);
    frame_dig -3
    frame_dig -2
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:176
    // assert(this.poolAssetA(poolKey).exists, "Pool does not exist");
    dup
    box_len
    bury 1
    assert // Pool does not exist
    // smart_contracts/swap_contract/AMMContract.algo.ts:178
    // const poolAssetA = this.poolAssetA(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // public poolAssetB = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pb_` });
    bytec_3 // "pb_"
    dig 2
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:179
    // const poolAssetB = this.poolAssetB(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:24
    // public poolReserveA = BoxMap<bytes, uint64>({ keyPrefix: Bytes`ra_` });
    bytec 4 // "ra_"
    dig 3
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:180
    // const reserveA = this.poolReserveA(poolKey).value;
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:25
    // public poolReserveB = BoxMap<bytes, uint64>({ keyPrefix: Bytes`rb_` });
    bytec 5 // "rb_"
    dig 5
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:181
    // const reserveB = this.poolReserveB(poolKey).value;
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public poolTotalLp = BoxMap<bytes, uint64>({ keyPrefix: Bytes`lp_` });
    bytec 6 // "lp_"
    dig 7
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:182
    // const totalLp = this.poolTotalLp(poolKey).value;
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:184
    // const lpKey = this.getLpBalanceKey(poolKey, Txn.sender);
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:59
    // return poolKey.concat(accountBytes);
    uncover 9
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // public lpBalances = BoxMap<bytes, uint64>({ keyPrefix: Bytes`bal_` });
    bytec 7 // "bal_"
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:186
    // assert(this.lpBalances(lpKey).exists, "No LP balance found");
    dup
    box_len
    bury 1
    assert // No LP balance found
    // smart_contracts/swap_contract/AMMContract.algo.ts:187
    // const userLp = this.lpBalances(lpKey).value;
    dup
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:189
    // assert(lpToBurn > Uint64(0), "Must burn positive amount");
    frame_dig -1
    assert // Must burn positive amount
    // smart_contracts/swap_contract/AMMContract.algo.ts:190
    // assert(userLp >= lpToBurn, "Insufficient LP balance");
    frame_dig -1
    >=
    assert // Insufficient LP balance
    // smart_contracts/swap_contract/AMMContract.algo.ts:193
    // const amtA: uint64 = reserveA * lpToBurn / totalLp;
    dig 5
    frame_dig -1
    *
    dig 2
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:194
    // const amtB: uint64 = reserveB * lpToBurn / totalLp;
    dig 4
    frame_dig -1
    *
    dig 3
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:197
    // this.poolReserveA(poolKey).value = reserveA - amtA;
    uncover 7
    dig 2
    -
    itob
    uncover 8
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:198
    // this.poolReserveB(poolKey).value = reserveB - amtB;
    uncover 5
    dig 1
    -
    itob
    uncover 6
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:199
    // this.poolTotalLp(poolKey).value = totalLp - lpToBurn;
    uncover 3
    frame_dig -1
    -
    itob
    uncover 4
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:202
    // this.lpBalances(lpKey).value -= lpToBurn;
    dig 2
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    frame_dig -1
    -
    itob
    uncover 3
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:205-211
    // itxn.assetTransfer({
    //   assetAmount: amtA,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetA,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_begin
    // smart_contracts/swap_contract/AMMContract.algo.ts:207
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:210
    // sender: Global.currentApplicationAddress
    global CurrentApplicationAddress
    itxn_field Sender
    uncover 4
    itxn_field XferAsset
    itxn_field AssetReceiver
    swap
    itxn_field AssetAmount
    // smart_contracts/swap_contract/AMMContract.algo.ts:205-211
    // itxn.assetTransfer({
    //   assetAmount: amtA,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetA,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/swap_contract/AMMContract.algo.ts:208
    // fee: Uint64(1),
    intc_1 // 1
    itxn_field Fee
    // smart_contracts/swap_contract/AMMContract.algo.ts:205-211
    // itxn.assetTransfer({
    //   assetAmount: amtA,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetA,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_submit
    // smart_contracts/swap_contract/AMMContract.algo.ts:213-219
    // itxn.assetTransfer({
    //   assetAmount: amtB,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetB,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_begin
    // smart_contracts/swap_contract/AMMContract.algo.ts:215
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:218
    // sender: Global.currentApplicationAddress
    global CurrentApplicationAddress
    itxn_field Sender
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/swap_contract/AMMContract.algo.ts:213-219
    // itxn.assetTransfer({
    //   assetAmount: amtB,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetB,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/swap_contract/AMMContract.algo.ts:216
    // fee: Uint64(1),
    intc_1 // 1
    itxn_field Fee
    // smart_contracts/swap_contract/AMMContract.algo.ts:213-219
    // itxn.assetTransfer({
    //   assetAmount: amtB,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: poolAssetB,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_submit
    // smart_contracts/swap_contract/AMMContract.algo.ts:221
    // return true;
    intc_1 // 1
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.swap(assetIdA: uint64, assetIdB: uint64, sendAssetId: uint64, swapAmount: uint64) -> uint64:
swap:
    // smart_contracts/swap_contract/AMMContract.algo.ts:225-230
    // public swap(
    //   assetIdA: Asset,
    //   assetIdB: Asset,
    //   sendAssetId: Asset,
    //   swapAmount: uint64
    // ): boolean {
    proto 4 1
    pushbytes ""
    dup
    // smart_contracts/swap_contract/AMMContract.algo.ts:231
    // ensureBudget(8000);
    pushint 8000 // 8000
    intc_0 // 0
    callsub ensure_budget
    // smart_contracts/swap_contract/AMMContract.algo.ts:233
    // assert(Global.groupSize === 2, "Expected group size of 2 (app call + asset transfer)");
    global GroupSize
    pushint 2 // 2
    ==
    assert // Expected group size of 2 (app call + asset transfer)
    // smart_contracts/swap_contract/AMMContract.algo.ts:235
    // const poolKey = this.getPoolKey(assetIdA, assetIdB);
    frame_dig -4
    frame_dig -3
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:236
    // assert(this.poolAssetA(poolKey).exists, "Pool does not exist");
    dup
    box_len
    bury 1
    assert // Pool does not exist
    // smart_contracts/swap_contract/AMMContract.algo.ts:238
    // const poolAssetA = this.poolAssetA(poolKey).value;
    box_get
    swap
    btoi
    dup
    cover 3
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // public poolAssetB = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pb_` });
    bytec_3 // "pb_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:239
    // const poolAssetB = this.poolAssetB(poolKey).value;
    box_get
    swap
    btoi
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:24
    // public poolReserveA = BoxMap<bytes, uint64>({ keyPrefix: Bytes`ra_` });
    bytec 4 // "ra_"
    dig 1
    concat
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:240
    // const reserveA = this.poolReserveA(poolKey).value;
    box_get
    swap
    btoi
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:25
    // public poolReserveB = BoxMap<bytes, uint64>({ keyPrefix: Bytes`rb_` });
    bytec 5 // "rb_"
    dig 1
    concat
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:241
    // const reserveB = this.poolReserveB(poolKey).value;
    box_get
    swap
    btoi
    cover 3
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public poolTotalLp = BoxMap<bytes, uint64>({ keyPrefix: Bytes`lp_` });
    bytec 6 // "lp_"
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:242
    // const totalLp = this.poolTotalLp(poolKey).value;
    box_get
    bury 1
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:250
    // if (sendAssetId === poolAssetA) {
    frame_dig -2
    ==
    bz swap_else_body@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:252
    // const k: uint64 = reserveA * reserveB;
    frame_dig 5
    dup
    dig 2
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:253
    // const newReserveATemp: uint64 = reserveA + swapAmount;
    swap
    frame_dig -1
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:34
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    intc_0 // 0
    bytec 9 // "FEE_DEN"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:254
    // const newReserveBTemp: uint64 = k * this.FEE_DEN.value / (newReserveATemp * this.FEE_NUM.value);
    uncover 2
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    intc_0 // 0
    bytec 8 // "FEE_NUM"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:254
    // const newReserveBTemp: uint64 = k * this.FEE_DEN.value / (newReserveATemp * this.FEE_NUM.value);
    dig 2
    *
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:256
    // outputAmount = reserveB - newReserveBTemp;
    dig 2
    swap
    -
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:258
    // newReserveB = reserveB - outputAmount;
    uncover 2
    swap
    -
    frame_bury 1
    frame_dig 3
    cover 2
    frame_bury 0

swap_after_if_else@3:
    // smart_contracts/swap_contract/AMMContract.algo.ts:273
    // this.poolReserveA(poolKey).value = newReserveA;
    frame_dig 0
    itob
    frame_dig 4
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:274
    // this.poolReserveB(poolKey).value = newReserveB;
    frame_dig 1
    itob
    frame_dig 6
    swap
    box_put
    // smart_contracts/swap_contract/AMMContract.algo.ts:278-284
    // itxn.assetTransfer({
    //   assetAmount: outputAmount,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: outputAsset,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_begin
    // smart_contracts/swap_contract/AMMContract.algo.ts:280
    // assetReceiver: Txn.sender,
    txn Sender
    // smart_contracts/swap_contract/AMMContract.algo.ts:283
    // sender: Global.currentApplicationAddress
    global CurrentApplicationAddress
    itxn_field Sender
    uncover 2
    itxn_field XferAsset
    itxn_field AssetReceiver
    itxn_field AssetAmount
    // smart_contracts/swap_contract/AMMContract.algo.ts:278-284
    // itxn.assetTransfer({
    //   assetAmount: outputAmount,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: outputAsset,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    intc_2 // 4
    itxn_field TypeEnum
    // smart_contracts/swap_contract/AMMContract.algo.ts:281
    // fee: Uint64(1),
    intc_1 // 1
    itxn_field Fee
    // smart_contracts/swap_contract/AMMContract.algo.ts:278-284
    // itxn.assetTransfer({
    //   assetAmount: outputAmount,
    //   assetReceiver: Txn.sender,
    //   fee: Uint64(1),
    //   xferAsset: outputAsset,
    //   sender: Global.currentApplicationAddress
    // }).submit();
    itxn_submit
    // smart_contracts/swap_contract/AMMContract.algo.ts:286
    // return true;
    intc_1 // 1
    frame_bury 0
    retsub

swap_else_body@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:262
    // const k: uint64 = reserveA * reserveB;
    frame_dig 5
    dup
    uncover 2
    dup
    cover 2
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:263
    // const newReserveBTemp: uint64 = reserveB + swapAmount;
    swap
    frame_dig -1
    +
    // smart_contracts/swap_contract/AMMContract.algo.ts:34
    // private readonly FEE_DEN = GlobalState<uint64>({ initialValue: Uint64(1000) });
    intc_0 // 0
    bytec 9 // "FEE_DEN"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:264
    // const newReserveATemp: uint64 = k * this.FEE_DEN.value / (newReserveBTemp * this.FEE_NUM.value);
    uncover 2
    *
    // smart_contracts/swap_contract/AMMContract.algo.ts:33
    // private readonly FEE_NUM = GlobalState<uint64>({ initialValue: Uint64(997) }); // 0.3% fee
    intc_0 // 0
    bytec 8 // "FEE_NUM"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/swap_contract/AMMContract.algo.ts:264
    // const newReserveATemp: uint64 = k * this.FEE_DEN.value / (newReserveBTemp * this.FEE_NUM.value);
    dig 2
    *
    /
    // smart_contracts/swap_contract/AMMContract.algo.ts:266
    // outputAmount = reserveA - newReserveATemp;
    dig 2
    swap
    -
    dup
    cover 3
    // smart_contracts/swap_contract/AMMContract.algo.ts:267
    // newReserveA = reserveA - outputAmount;
    uncover 2
    swap
    -
    frame_bury 0
    frame_dig 2
    cover 2
    frame_bury 1
    b swap_after_if_else@3


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.getLpBalance(assetIdA: uint64, assetIdB: uint64, account: bytes) -> uint64:
getLpBalance:
    // smart_contracts/swap_contract/AMMContract.algo.ts:290
    // public getLpBalance(assetIdA: Asset, assetIdB: Asset, account: Account): uint64 {
    proto 3 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:291
    // const poolKey = this.getPoolKey(assetIdA, assetIdB);
    frame_dig -3
    frame_dig -2
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:59
    // return poolKey.concat(accountBytes);
    frame_dig -1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:30
    // public lpBalances = BoxMap<bytes, uint64>({ keyPrefix: Bytes`bal_` });
    bytec 7 // "bal_"
    swap
    concat
    dup
    // smart_contracts/swap_contract/AMMContract.algo.ts:294
    // if (!this.lpBalances(lpKey).exists) {
    box_len
    bury 1
    bnz getLpBalance_after_if_else@2
    // smart_contracts/swap_contract/AMMContract.algo.ts:295
    // return Uint64(0);
    intc_0 // 0
    swap
    retsub

getLpBalance_after_if_else@2:
    // smart_contracts/swap_contract/AMMContract.algo.ts:297
    // return this.lpBalances(lpKey).value;
    frame_dig 0
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    swap
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.getPoolInfo(assetIdA: uint64, assetIdB: uint64) -> uint64, uint64, uint64, uint64, uint64:
getPoolInfo:
    // smart_contracts/swap_contract/AMMContract.algo.ts:301
    // public getPoolInfo(assetIdA: Asset, assetIdB: Asset): [uint64, uint64, uint64, uint64, uint64] {
    proto 2 5
    // smart_contracts/swap_contract/AMMContract.algo.ts:302
    // const poolKey = this.getPoolKey(assetIdA, assetIdB);
    frame_dig -2
    frame_dig -1
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    dig 1
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:303
    // assert(this.poolAssetA(poolKey).exists, "Pool does not exist");
    dup
    box_len
    bury 1
    assert // Pool does not exist
    // smart_contracts/swap_contract/AMMContract.algo.ts:305
    // const poolAssetA = this.poolAssetA(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:23
    // public poolAssetB = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pb_` });
    bytec_3 // "pb_"
    dig 2
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:306
    // const poolAssetB = this.poolAssetB(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:24
    // public poolReserveA = BoxMap<bytes, uint64>({ keyPrefix: Bytes`ra_` });
    bytec 4 // "ra_"
    dig 3
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:307
    // const reserveA = this.poolReserveA(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:25
    // public poolReserveB = BoxMap<bytes, uint64>({ keyPrefix: Bytes`rb_` });
    bytec 5 // "rb_"
    dig 4
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:308
    // const reserveB = this.poolReserveB(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:26
    // public poolTotalLp = BoxMap<bytes, uint64>({ keyPrefix: Bytes`lp_` });
    bytec 6 // "lp_"
    uncover 5
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:309
    // const totalLp = this.poolTotalLp(poolKey).value;
    box_get
    swap
    btoi
    swap
    assert // Box must have value
    // smart_contracts/swap_contract/AMMContract.algo.ts:311-317
    // return [
    //   poolAssetA.id,
    //   poolAssetB.id,
    //   reserveA,
    //   reserveB,
    //   totalLp,
    // ];
    retsub


// smart_contracts/swap_contract/AMMContract.algo.ts::MultiPoolAMMContract.poolExists(assetIdA: uint64, assetIdB: uint64) -> uint64:
poolExists:
    // smart_contracts/swap_contract/AMMContract.algo.ts:321
    // public poolExists(assetIdA: Asset, assetIdB: Asset): boolean {
    proto 2 1
    // smart_contracts/swap_contract/AMMContract.algo.ts:322
    // const poolKey = this.getPoolKey(assetIdA, assetIdB);
    frame_dig -2
    frame_dig -1
    callsub getPoolKey
    // smart_contracts/swap_contract/AMMContract.algo.ts:22
    // public poolAssetA = BoxMap<bytes, Asset>({ keyPrefix: Bytes`pa_` });
    bytec_1 // "pa_"
    swap
    concat
    // smart_contracts/swap_contract/AMMContract.algo.ts:323
    // return this.poolAssetA(poolKey).exists;
    box_len
    bury 1
    retsub
